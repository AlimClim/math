<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Управляемый Тор</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: #aaa; font-family: sans-serif; }
        canvas { display: block; }
        
        /* Стили панели управления */
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 20, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            width: 220px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            user-select: none;
        }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 12px; margin-bottom: 4px; color: #fff; }
        input[type=range] { width: 100%; cursor: pointer; }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            color: rgba(255,255,255,0.5);
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="info">Вращайте фигуру мышкой</div>

    <div id="controls">
        <div class="control-group">
            <label>Скорость движения</label>
            <input type="range" id="speedRange" min="0" max="3" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Цвет (Оттенок)</label>
            <input type="range" id="hueRange" min="0" max="360" step="1" value="200">
        </div>
        <div class="control-group">
            <label>Яркость / Непрозрачность</label>
            <input type="range" id="alphaRange" min="0.1" max="1" step="0.05" value="0.7">
        </div>
        <div class="control-group">
            <label>Длина шлейфа (Fade)</label>
            <input type="range" id="trailRange" min="0.02" max="0.3" step="0.01" value="0.1">
        </div>
    </div>

    <canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;

// --- КОНФИГУРАЦИЯ ---
// Объект, который хранит текущие настройки с ползунков
const config = {
    speed: 1.0,
    baseHue: 200,
    alpha: 0.7,
    fadeAmount: 0.1
};

// Подключение ползунков
document.getElementById('speedRange').oninput = (e) => config.speed = parseFloat(e.target.value);
document.getElementById('hueRange').oninput = (e) => config.baseHue = parseFloat(e.target.value);
document.getElementById('alphaRange').oninput = (e) => config.alpha = parseFloat(e.target.value);
document.getElementById('trailRange').oninput = (e) => config.fadeAmount = parseFloat(e.target.value);

let width, height, cx, cy;
const R = 180; 
const r_tube = 70; 
const numParticles = 600;
const particles = [];

let angleX = 0.6;
let angleY = 0.3;
let mouseX = 0; let mouseY = 0;
let isDragging = false;

class Particle {
    constructor() {
        this.reset();
        // Рандомизация начальной позиции
        this.theta = Math.random() * Math.PI * 2;
        this.phi = Math.random() * Math.PI * 2;
        
        this.prevX = null;
        this.prevY = null;
    }

    reset() {
        this.dist = Math.sqrt(Math.random()) * r_tube;
        
        // Базовые скорости (направление может быть разным)
        this.baseSpeedTheta = (0.005 + Math.random() * 0.005) * (Math.random() < 0.5 ? 1 : -1);
        this.baseSpeedPhi = (0.02 + Math.random() * 0.03) * (Math.random() < 0.5 ? 1 : -1);
        
        // Индивидуальное отклонение цвета для красоты
        this.hueOffset = Math.random() * 40 - 20; 
    }

    update() {
        // Умножаем базовую скорость на глобальный коэффициент скорости
        this.theta += this.baseSpeedTheta * config.speed;
        this.phi += this.baseSpeedPhi * config.speed;
    }

    draw(ctx, cosX, sinX, cosY, sinY) {
        const r_effective = R + this.dist * Math.cos(this.phi);
        let x = r_effective * Math.cos(this.theta);
        let y = r_effective * Math.sin(this.theta);
        let z = this.dist * Math.sin(this.phi);

        let x1 = x * cosY - z * sinY;
        let z1 = z * cosY + x * sinY;
        let y2 = y * cosX - z1 * sinX;
        let z2 = z1 * cosX + y * sinX;

        const fov = 500;
        const scale = fov / (fov + z2);
        const x2d = x1 * scale + cx;
        const y2d = y2 * scale + cy;

        if (z2 > -fov * 0.9 && scale > 0.1) {
            if (this.prevX !== null && Math.abs(x2d - this.prevX) < 100) {
                ctx.beginPath();
                ctx.moveTo(this.prevX, this.prevY);
                ctx.lineTo(x2d, y2d);
                
                // ДИНАМИЧЕСКИЙ ЦВЕТ
                // Используем config.baseHue + индивидуальное отклонение
                // Используем config.alpha для яркости
                const h = (config.baseHue + this.hueOffset) % 360;
                ctx.strokeStyle = `hsla(${h}, 80%, 60%, ${config.alpha})`;
                
                ctx.lineWidth = scale * dpr * 1.5; 
                ctx.lineCap = 'round';
                ctx.stroke();
            }
            this.prevX = x2d;
            this.prevY = y2d;
        } else {
            this.prevX = null;
            this.prevY = null;
        }
    }
}

function init() {
    resize();
    for (let i = 0; i < numParticles; i++) {
        particles.push(new Particle());
    }
    window.addEventListener('resize', resize);
    
    canvas.addEventListener('mousedown', e => { isDragging = true; mouseX = e.clientX; mouseY = e.clientY; });
    window.addEventListener('mouseup', () => { isDragging = false; });
    window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        angleY += (e.clientX - mouseX) * 0.005;
        angleX += (e.clientY - mouseY) * 0.005;
        mouseX = e.clientX; mouseY = e.clientY;
    });
    
    animate();
}

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    cx = width / 2;
    cy = height / 2;
}

function animate() {
    // Используем config.fadeAmount для управления длиной хвоста
    // Цвет фона должен быть черным (RGB 0,0,0), меняем только Alpha
    ctx.fillStyle = `rgba(5, 5, 5, ${config.fadeAmount})`;
    ctx.fillRect(0, 0, width, height);

    ctx.globalCompositeOperation = 'lighter';

    const cosX = Math.cos(angleX);
    const sinX = Math.sin(angleX);
    const cosY = Math.cos(angleY);
    const sinY = Math.sin(angleY);

    for (let p of particles) {
        p.update();
        p.draw(ctx, cosX, sinX, cosY, sinY);
    }
    
    ctx.globalCompositeOperation = 'source-over';
    requestAnimationFrame(animate);
}

init();
</script>
</body>
</html>