<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Фигура ровно по центру</title>
    <style>
        /* 1. ГАРАНТИЯ ПОЛНОГО ЭКРАНА */
        body, html { 
            margin: 0; padding: 0; 
            width: 100%; height: 100%; 
            background-color: #000; 
            overflow: hidden; /* Нет скролла */
            font-family: 'Segoe UI', sans-serif;
            -webkit-user-select: none; user-select: none;
            position: fixed; /* Фиксация для iOS */
        }

        /* 2. КАНВАС НА ВЕСЬ ЭКРАН */
        canvas { 
            display: block; 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%;
            z-index: 1;
        }

        /* Меню настроек */
        #ui-layer {
            position: absolute;
            top: 0; right: 0;
            width: 260px;
            height: 100%;
            background: rgba(10,12,15, 0.9);
            border-left: 1px solid #333;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
        }
        
        #ui-layer.open { transform: translateX(0); }

        /* Кнопка меню */
        #gear-btn {
            position: absolute;
            top: 20px; right: 20px;
            z-index: 20;
            background: rgba(0,0,0,0.6);
            border: 1px solid #555;
            color: #fff;
            width: 40px; height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex; align-items: center; justify-content: center;
        }

        .control-block { margin-bottom: 20px; }
        label { display: block; color: #888; font-size: 11px; margin-bottom: 5px; text-transform: uppercase; }
        .val-disp { float: right; color: #00d2ff; }
        input[type=range] { width: 100%; accent-color: #00d2ff; cursor: pointer; }
        select { width: 100%; padding: 8px; background: #222; color: #fff; border: 1px solid #444; border-radius: 4px; }

        /* Адаптив: На больших экранах меню можно оставить открытым */
        @media (min-width: 1024px) {
            #ui-layer { transform: translateX(0); background: rgba(10,12,15, 0.8); }
            #gear-btn { display: none; } /* Скрываем кнопку на ПК */
        }
    </style>
</head>
<body>

    <div id="gear-btn">⚙️</div>

    <div id="ui-layer">
        <h3 style="color:#fff; margin-top:0;">Настройки</h3>
        
        <div class="control-block">
            <label>Форма движения</label>
            <select id="sel-motion">
                <option value="torus">Тор (Пончик)</option>
                <option value="sphere">Сфера (Атом)</option>
                <option value="vortex">Вихрь (Воронка)</option>
                <option value="cube">Куб (Лиссажу)</option>
                <option value="rain">Матрица (Дождь)</option>
            </select>
        </div>

        <div class="control-block">
            <label>Зум (Вход внутрь) <span class="val-disp" id="disp-zoom"></span></label>
            <input type="range" id="rng-zoom" min="0.5" max="5.0" step="0.1" value="1.0">
        </div>

        <div class="control-block">
            <label>Скорость <span class="val-disp" id="disp-speed"></span></label>
            <input type="range" id="rng-speed" min="0" max="4.0" step="0.1" value="1.0">
        </div>

        <div class="control-block">
            <label>Длина шлейфа <span class="val-disp" id="disp-trail"></span></label>
            <input type="range" id="rng-trail" min="0.03" max="0.4" step="0.01" value="0.1">
        </div>

        <div class="control-block">
            <label>Цвет (Спектр) <span class="val-disp" id="disp-hue"></span></label>
            <input type="range" id="rng-hue" min="0" max="360" step="1" value="200">
        </div>
        
        <div class="control-block">
            <label>Прозрачность <span class="val-disp" id="disp-alpha"></span></label>
            <input type="range" id="rng-alpha" min="0.1" max="1" step="0.1" value="0.8">
        </div>
    </div>

    <canvas id="canvas"></canvas>

<script>
// --- СИСТЕМНЫЕ ПЕРЕМЕННЫЕ ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;

let width, height, cx, cy;
const particles = [];
const numParticles = 750;

// --- НАСТРОЙКИ (State) ---
const state = {
    motion: 'torus',
    zoom: 1.0,
    speed: 1.0,
    trail: 0.1, // Значение прозрачности фона (меньше = длиннее хвост)
    hue: 200,
    alpha: 0.8
};

// --- СВЯЗЬ С ИНТЕРФЕЙСОМ ---
const ui = {
    btn: document.getElementById('gear-btn'),
    panel: document.getElementById('ui-layer'),
    inputs: {
        motion: document.getElementById('sel-motion'),
        zoom: document.getElementById('rng-zoom'),
        speed: document.getElementById('rng-speed'),
        trail: document.getElementById('rng-trail'),
        hue: document.getElementById('rng-hue'),
        alpha: document.getElementById('rng-alpha')
    },
    disps: {
        zoom: document.getElementById('disp-zoom'),
        speed: document.getElementById('disp-speed'),
        trail: document.getElementById('disp-trail'),
        hue: document.getElementById('disp-hue'),
        alpha: document.getElementById('disp-alpha')
    }
};

// Обработчики UI
ui.btn.onclick = () => ui.panel.classList.toggle('open');

function updateState() {
    state.motion = ui.inputs.motion.value;
    state.zoom = parseFloat(ui.inputs.zoom.value);
    state.speed = parseFloat(ui.inputs.speed.value);
    state.trail = parseFloat(ui.inputs.trail.value);
    state.hue = parseInt(ui.inputs.hue.value);
    state.alpha = parseFloat(ui.inputs.alpha.value);

    // Обновляем текст
    ui.disps.zoom.innerText = state.zoom.toFixed(1);
    ui.disps.speed.innerText = state.speed.toFixed(1);
    ui.disps.trail.innerText = (1 / state.trail).toFixed(1);
    ui.disps.hue.innerText = state.hue;
    ui.disps.alpha.innerText = state.alpha;
    
    // Сброс следов при резких изменениях
    if(document.activeElement === ui.inputs.motion) resetScreen();
}

Object.values(ui.inputs).forEach(el => el.oninput = updateState);
updateState(); // Инициализация

// --- КЛАСС ЧАСТИЦЫ ---
class Particle {
    constructor() {
        this.reset();
        this.prevX = null;
        this.prevY = null;
    }

    reset() {
        // Базовые координаты (0..2PI)
        this.u = Math.random() * Math.PI * 2;
        this.v = Math.random() * Math.PI * 2;
        // Случайные множители для вариативности
        this.rnd1 = Math.random();
        this.rnd2 = Math.random();
        this.speedMod = 0.5 + Math.random();
    }

    getPos(t) {
        let x, y, z;
        const m = state.motion;
        
        // 1. ТОРУС (Пончик)
        if (m === 'torus') {
            const R = 150; 
            const r = 60; 
            const angle1 = this.u + t * 0.5;
            const angle2 = this.v + t * 2.0;
            const r_eff = R + r * Math.cos(angle2);
            x = r_eff * Math.cos(angle1);
            y = r_eff * Math.sin(angle1);
            z = r * Math.sin(angle2);
        }
        // 2. СФЕРА (Вращение)
        else if (m === 'sphere') {
            const r = 160;
            // Орбитальное движение
            const theta = this.u + t * this.speedMod;
            const phi = this.v;
            x = r * Math.sin(phi) * Math.cos(theta);
            y = r * Math.sin(phi) * Math.sin(theta); // Сдвиг орбиты
            z = r * Math.cos(phi);
            // Добавляем "волнение"
            y += Math.sin(theta * 3) * 20;
        }
        // 3. ВИХРЬ
        else if (m === 'vortex') {
            const phase = (t * 0.3 + this.rnd1) % 1; // 0 -> 1
            const r = (1 - phase) * 300; // Сужается
            const theta = this.u + t * (2 + phase * 4); // Ускоряется
            x = r * Math.cos(theta);
            z = r * Math.sin(theta);
            y = (phase * 500) - 250; // Падает вниз
        }
        // 4. КУБ (Лиссажу)
        else if (m === 'cube') {
            const s = 180;
            x = s * Math.sin(t * 1.1 + this.u);
            y = s * Math.sin(t * 1.5 + this.v);
            z = s * Math.sin(t * 1.9);
        }
        // 5. ДОЖДЬ
        else if (m === 'rain') {
            const w = 400;
            x = (this.rnd1 - 0.5) * w;
            z = (this.rnd2 - 0.5) * w;
            const h = 600;
            let py = (this.v * 100 + t * 200) % h;
            y = py - h/2;
        }

        return {x, y, z};
    }

    draw(ctx, t, rotX, rotY) {
        const p = this.getPos(t);
        let {x, y, z} = p;

        // ВРАЩЕНИЕ ВОКРУГ ЦЕНТРА (0,0,0)
        // Ось Y
        let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
        let z1 = z * Math.cos(rotY) + x * Math.sin(rotY);
        // Ось X
        let y2 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
        let z2 = z1 * Math.cos(rotX) + y * Math.sin(rotX);

        // КАМЕРА (ЗУМ)
        // Смещаем мир назад, чтобы "влететь" вперед
        const camOffset = (state.zoom - 1) * 200;
        z2 -= camOffset;

        // ПРОЕКЦИЯ
        const fov = 500;
        const scale = fov / (fov + z2);

        if (z2 <= -fov + 10) {
            this.prevX = null;
            return;
        }

        // --- ГЛАВНАЯ МАГИЯ ЦЕНТРОВКИ ---
        // Мы рассчитываем координаты относительно центра (cx, cy)
        // cx и cy обновляются при каждом ресайзе окна
        const screenX = x1 * scale + cx;
        const screenY = y2 * scale + cy;

        // РИСОВАНИЕ
        if (this.prevX !== null && scale > 0) {
            // Защита от длинных линий
            const dist = Math.abs(screenX - this.prevX) + Math.abs(screenY - this.prevY);
            if (dist < 150) {
                ctx.beginPath();
                ctx.moveTo(this.prevX, this.prevY);
                ctx.lineTo(screenX, screenY);

                // Динамический цвет
                const h = (state.hue + z2 * 0.2) % 360;
                const a = Math.min(state.alpha, scale); // Дальние прозрачнее

                ctx.strokeStyle = `hsla(${h}, 80%, 60%, ${a})`;
                ctx.lineWidth = scale * dpr * (state.zoom > 2 ? 3 : 1.5);
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }

        this.prevX = screenX;
        this.prevY = screenY;
    }
}

// --- УПРАВЛЕНИЕ РАЗМЕРАМИ И ЦИКЛОМ ---

function resize() {
    // 1. Получаем реальные размеры окна
    width = window.innerWidth;
    height = window.innerHeight;

    // 2. Настраиваем буфер канваса (для ретины x2/x3)
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    
    // 3. Масштабируем контекст
    ctx.scale(dpr, dpr);

    // 4. СЧИТАЕМ ЦЕНТР (Это самое важное)
    cx = width / 2;
    cy = height / 2;
    
    // Сбрасываем экран, чтобы не было растянутых линий
    resetScreen();
}

function resetScreen() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);
    particles.forEach(p => p.prevX = null);
}

// Инициализация частиц
for (let i = 0; i < numParticles; i++) particles.push(new Particle());

window.addEventListener('resize', resize);
resize(); // Первый вызов

// --- ОБРАБОТКА МЫШИ / ТАЧА ---
let rotX = 0, rotY = 0;
let isDrag = false, lastX, lastY;

// Pointer Events (Универсально для ПК и Телефона)
canvas.addEventListener('pointerdown', e => {
    isDrag = true; lastX = e.clientX; lastY = e.clientY;
    canvas.setPointerCapture(e.pointerId); // Захват пальца
});
canvas.addEventListener('pointerup', e => {
    isDrag = false; canvas.releasePointerCapture(e.pointerId);
});
canvas.addEventListener('pointermove', e => {
    if (!isDrag) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    rotY += dx * 0.005;
    rotX += dy * 0.005;
    lastX = e.clientX; lastY = e.clientY;
});

// --- АНИМАЦИЯ ---
let time = 0;

function animate() {
    // Полупрозрачная заливка (шлейф)
    ctx.fillStyle = `rgba(0, 0, 0, ${state.trail})`;
    ctx.fillRect(0, 0, width, height);
    
    ctx.globalCompositeOperation = 'lighter';

    time += 0.01 * state.speed;

    for (let p of particles) {
        p.draw(ctx, time, rotX, rotY);
    }
    
    ctx.globalCompositeOperation = 'source-over';
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
